# 部分和問題

> N個の正の整数 a0, a1, ..., aN-1 と正の整数 W がある。<br>a0, a1, ..., aN-1 の中からいくつかを選んで総和を W にすることができるかを判定してください。

# 方針

再帰呼び出しを使って解を求めます。

a0, a1, ..., aN-1 から数個選んで和 W が作成可能かという問題は、aN-1に着目すると以下の2つの問題に分けられます。

1. aN-1 を除いた a0, a1, ..., aN-2 までの N-1 個から数個選んで和 W になるか（最終的な和 W に aN-1 が含まれないパターン）
2. aN-1 を除いた a0, a1, ..., aN-2 までの N-1 個から数個選んで和 (W - aN-1) になるか（最終的な和 W に aN-1 が含まれるパターン）

## 例えば

> N: 集合の要素数、a: 集合, W: 目的の合計値
> N=3, a=(2,6,5), W=14

という場合、
```
3個の整数集合からいくつかを選んで 14 を作りたい
```
ということですが、これは
```
2個の整数集合からいくつかを選んで 14, または 9 を作りたい
```
という問題に帰結され、さらに
```
1個の整数集合からいくつかを選んで 14, 8, 9, 3 を作りたい
```
となり、最終的には
```
0個の整数集合からいくつかを選んで 14, 12, 8, 6, 9, 7, 3, 1 を作りたい
```
となります。

0個の整数集合の和は常に0であるので、出したい和の中に 0 があれば Yes であると言えます。

# 解答

今回の解答を出すための再帰関数は以下のように定義します。

> func bool(i: Int, w: Int) -> Bool <br>
> a0, a1, ..., aN-1 の整数のうち、最初の i 個から何個か選んで総和を w とできるかを判定する

ベースケースは i=0 の時です。これは
```
0個の整数を選んで総和を w とすることができるか
```
を意味します。

つまり、総和:w が 0 であれば true です。

```swift
func bool(i: Int, w: Int, a: [Int]) -> Bool {
  // 0個を選ぶ時: 添字が 0 未満
  if i < 0 {
    return w == 0
  }
  // i番目の整数が総和に含まれる or 含まれないケースを考慮する
  // そのいずれかが true となれば、最終的に返却する値も true となる
  return bool(i: i-1, w: w) || bool(i: i-1, w: w-a[i])
}

let a = [3,2,6,5]
let w = 14
print(bool(i: a.count-1, w: w, a: a) ? "Yes" : "No")
```

### 結果
```shell
Yes
```

# この技法は分割統治法の一種

このように `ある問題を部分問題に分割して各部分問題を再帰的に解き、それらの解を組み合わせて元の問題の解を構成する` 技法を **分割統治法** と呼びます。

この分割統治法は基本的な考え方なので、無意識に用いられることも多いです。