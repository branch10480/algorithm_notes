# 編集距離

これまでの動的計画法は **N個の項目を扱う問題に対して最初の i個に関する問題を部分問題として i を進めながら更新していく** というタイプでした。

ここでは **系列が複数あって、系列に沿って進んでいる添字も複数ある** タイプの動的計画法を扱います。

具体的には `編集距離` と呼ばれる問題について考えます。

編集距離とは `文字列 S,T の類似度を測るもの` です。

この編集距離は以下のような応用があり、重要な項目です。

- diff コマンド
- スペルチェッカー
- 空間・画像・音声認識などのパターンマッチング
- バイオインフォマティクス（2つのDNA間の類似度を測るなどの用途に用いられ、 **系列アラインメント: sequence alignment とも呼ばれます**）

# 類似度

## 例1
`S="bag"` と `T="big"` は真ん中の1文字のみが異なるので、 **類似度は 1** であると考えることができます。

## 例2
`S="kodansha"` と `T="danshari"` については、Sから先頭 "ko" を削除して末尾に "ri" を加えると Tに一致するため、 **類似度は 2 + 2 = 4** であると言えます。

# 例題

> 2つの文字列 S,T が与えられます。<br>
> Sに以下の3通りの操作を繰り返し施すことで T に変換したい場合、そのような一連の操作のうち、操作回数の最小値を求めてください。
> 
> なお、この最小値を S と T の **編集距離** と言います。
> 
> - 変更: S内の文字を1つ選んで任意の文字に変更する
> - 削除: S内の文字を1つ選んで削除する
> - 挿入: Sの好きな箇所に好きな文字を1文字挿入する

今回の場合、

```swift
let S = "logistic"
let T = "algorithm"
```

について考えることにします。

## 着眼点

以下の操作が等価であることに着目します。

**S -> Tへの変換**
```
Sの好きな箇所に好きな文字を1文字挿入する
```

**T -> Sへの変換**
```
Tの文字を1つ選んで削除する
```

## 解答までの足掛かり

動的計画法の部分問題（テーブル）を以下のように定義します。

> dp[i][j] ...<br>
> Sの最初の i文字分と Tの最初の j文字分との間の編集距離

まず初期条件は `dp[0][0] = 0` となります。<br>
これはつまり **Sの最初の0文字分** と **Tの最初の0文字分** がともに空文字を表しており、同一となるため変更操作は不要で `操作数0` となります。

次に遷移を考えます。<br>
方針は以下です。

> Sの最初の i文字分と Tの最初の j文字分とで **最後の1文字をどのように対応したか** で場合分けする

## dp[i][j] を緩和する方法を考える

緩和に使うメソッドをこのように定義します。

```swift
func chmin(target: inout Int, new: Int) {
  target = min(target, new)
}
```
### 1. 最後の文字同士に変更操作を行う場合

#### S[i-1] == T[j-1] の場合

まず最初に注意するべきは `dp[i][j]` は Sの **i文字目まで** と Tの **j文字目まで** についての操作最小値を表すことです。

この場合の S、Tの最後の文字の添字は `i-1` , `j-1` となります。

さて、その上で `S[i-1]` と `T[j-1]` が等しいということは、今回扱う文字の最後が等しいということ、かつ `dp[i-1][j-1]` はすでに解決できているという前提に立つと以下の緩和処理を実行できます。

```swift
chmin(target: dp[i][j], new: dp[i-1][j-1])
```

#### S[i-1] != T[j-1] の場合

S, もしくは T に挿入・削除操作が必要になるため、以下の緩和処理になります。

```swift
chmin(target: dp[i][j], new: dp[i-1][j-1] + 1)
```

### 2. 求める文字列のどちらか一方から一文字欠けている編集距離からの編集距離を考える

求めたい編集距離が dp[i][j] の場合、どちらか最後の文字が欠けている場合の編集距離は 

`dp[i-1][j]` か `dp[i][j-1]` 。

ここから欠けている文字に対して挿入または削除操作をすることで求めたい編集距離候補となる。

よって、

```swift
chmin(target: dp[i][j], new: dp[i-1][j] + 1)
chmin(target: dp[i][j], new: dp[i][j-1] + 1)
```

で緩和する。

### 解答

以上を考慮すると、以下のような解答になる。

```swift
// 緩和用のメソッド
func chmin(target: inout Int, new: Int) {
  if new < target {
    target = new
  }
}

let S = "logistic"
let T = "algorithm"

let s: [Character] = Array(S)
let t: [Character] = Array(T)

// 文字列 S = (s0, s1, ..., sm-1)
// 文字列 T = (t0, t1, ..., tn-1)
//
// この二つの文字列について、
// Sについて最初の m文字分、
// Tについて最初の n文字分 同士の編集距離を dp[m][n] とする。
// （注意すべきは S の最初の m文字分ということは最後の一文字は S[m-1] ということ）

var dp = Array(
  repeating: Array(repeating: Int.max, count: t.count + 1),
  count: s.count + 1
)

for i in 0...s.count {
  for j in 0...t.count {

    // dp[i][j] を考える時、ここに至るまでの経路は以下の3つ
    // 1. dp[i-1][j] の編集距離に S[i-1] について編集操作を一回行う
    // 2. dp[i][j-1] の編集距離に T[j-1] について編集操作を一回行う
    // 3. dp[i-1][j-1] の編集距離に S[i-1], T[j-1] について必要であれば
    //    編集操作を一回行う

    if i == 0, j == 0 {
      dp[i][j] = 0
      continue
    }

    // 1. dp[i-1][j] の編集距離に S[i-1] について編集操作を一回行う
    if i > 0 {
      chmin(target: &dp[i][j], new: dp[i-1][j] + 1)
    }

    // 2. dp[i][j-1] の編集距離に T[j-1] について編集操作を一回行う
    if j > 0 {
      chmin(target: &dp[i][j], new: dp[i][j-1] + 1)
    }

    // 3. dp[i-1][j-1] の編集距離に S[i-1], T[j-1] について必要であれば
    //    編集操作を一回行う
    if i > 0, j > 0 {
      let edOfEnds = s[i-1] == t[j-1] ? 0 : 1
      chmin(target: &dp[i][j], new: dp[i-1][j-1] + edOfEnds)
    }
  }
}

print("Edit-distance is", dp[S.count][T.count])
```