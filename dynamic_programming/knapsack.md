# ナップザック問題

動的計画法の練習問題として有名なのが **ナップザック問題** です。

一応注意しておくべきは、この問題は動的計画法意外にも解法が存在することです。(分岐限定法に基づいた解法、貪欲法に基づいた近似解法)

ナップザック問題は、組み合わせ全探索、再帰を用いる全探索で出てきた部分和問題によく似ています。

## 問題

> N個の品物があり、 i(=0,1,..,N-1) 番目の品物の重さは weight i 、価値は value i で与えられます。<br> 
> 
> このN個の品物から、重さの総和が W を超えないようにいくつか選びます。選んだ品物の価値の総和として考えられる最大値を求めてください。<br>
> 
> ただし、W や weight i は 0 以上の整数とします。

## 解答の方針

動的計画法で解決できるかなりの問題は以下を意識して部分問題を構成し、部分問題同士の遷移関係を考察することで解けます。

> N個の対象物 0,1,2,...,N-1 に関する問題に対し、最初の i個の対象物 0,1,2,...,i-1 に関する問題を部分問題としてとらえる

まずは今回の問題について部分問題（テーブル）を定義します。

> dp[i] ... <br>
> 
> 最初の i個の品物 {0,1,...,i-1} までの中から重さが W を超えないように選んだときの価値 value の総和の最大値<br>
> 
> 注意！: Wは今回求める問題全体の総和 W であり、部分問題における最大値ではない

しかし、このままだと dp[i] から dp[i+1] の遷移を考える時、iを加えるかどうかを考えることになりますが（dp[i] は 品物 0,1,...,i-1 までの中で考えた場合の価値の和の最大値）、重さの合計が W を超えてしまうかどうかがわかりません。（dpはあくまで価値の最大値を表し、その時点での重さを保持していない）

よって、部分問題（テーブル）の定義を以下のように変更します。

> dp[i][w] ... <br>
>
> 最初の i個の品物 {0,1,...,i-1} までの中から重さが w を超えないように選んだ時の価値の最大値
> 
> 注意！: W と w は別

動的計画法はこのように、 **考えられる場合をグループごとにまとめるイメージ** の手法です。

**グループの個数とグループ間の遷移の個数が最終的な計算量になります**。<br>
したがってできるだけ大きなグループにまとめたいところですが、やりすぎると遷移が作れなくなる傾向があります。

遷移を考えられる程度にグループの粒度をできるだけ大きくしていくことが重要です。

## 解答

ナップザック問題を解答するにあたり、dpについて定義します。

```
dp[0][w] = 0 (w=0,1,...,W)
```

初期条件は品物が 0個の中で考える場合で、このとき重さは 0 になります。

次に `dp[i+1][w]` を考えます。

ここで緩和用のメソッド `chmax: Choose max` を用意します。

```swift
func chmax(target: inout Int, new: Int) {
  if new >= 0 {
    target = max(target, new)
  }
}
```

遷移について場合分けします。

### i番目の品物を選ぶ場合

i+1 のケース（最初の i+1 個の中から考える場合。つまり品物 0,1,...,i までの品物）です。

i+1 のケースに対応した重さの合計 w について、 i のケースとの関係性を比較する場合は `d[i][w - weights[i]` を考えることになります。

添字に用いる `w - weights[i]` について `>= 0` が成り立っている必要です。

```swift
// i番目を選ぶ場合
if w - weights[i] >= 0 {
  chmax(target: &dp[i + 1][w], new: p.value + dp[i][w - weights[i]])
}
```

### i番目の品物を選ばない場合

選ばなければ i のケースと比較して重さについては w で等しくなります。

```swift
// i番目を選ばない場合
chmax(target: &dp[i + 1][w], new: dp[i][w])
```

### 最終解

```swift
let W = 5    // 重さの上限
let products: [(weight: Int, value: Int)] = [
  (2, 3),
  (1, 5),
  (3, 0),
  (5, 1),
]
// 品物の個数
let N = products.count

// 品物のうち、最初の i個からいくつか選んで、
// 重さ W 以下になる価値の最大値を格納するテーブル
// w はこの時点での重さを表す
// 添字の意味的に、枠は W+1, N+1 用意することに注意！
// dp[i] i(=0,1,2,...,N) N+1個
// dp[i][w] w(=0,1,2,...,W) W+1個
var dp = Array(
  repeating: Array(repeating: 0, count: W + 1),
  count: N + 1
)

func chmax(target: inout Int, new: Int) {
  if new >= 0 {
    target = max(target, new)
  }
}

let weights = products.map {
  $0.weight
}
for i in 0..<N {
  let p = products[i]
  // 場合分けして緩和を実行する
  //
  // i+1 について考える
  // つまり、i+1 の時は、前から i 番目の品物までの間について（添字は 0始まり）
  // 品物 {0,1,...,i} 品物 i+1 は含まれない

  // w は dp[i] になる時の重さの合計
  // w(=0,1,...,W)
  for w in 0...W {
    // i番目を選ぶ場合
    if w - weights[i] >= 0 {
      chmax(target: &dp[i + 1][w], new: p.value + dp[i][w - weights[i]])
    }
    // i番目を選ばない場合
    chmax(target: &dp[i + 1][w], new: dp[i][w])
  }
}

print("最大価値は", dp[N][W])
```

#### 結果

```shell
最大価値は 8
```
