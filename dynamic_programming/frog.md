# カエル問題

## 問題

> N個の足場があり、各足場の高さは hi(i=0,1,2,...N-1)で与えられる。<br>
> カエルは以下のいずれかの行動をする
>
> 1. 足場 i から i+1 へと移動する（コストは |hi - hi+1|)
> 2. 足場 i から i+2 へと移動する（コストは |hi - hi+2|)
> 
> カエルが N-1 番目の足場にたどり着くまでに要するコストの総和の最小値を求めてください。

対象物の関係性を `丸` と `矢印` で表したものを **グラフ** といい、丸のことを **頂点** 、矢印のことを **辺** と呼びます。

## まずは具体的なケースで考えていく

わかりやすくするため、以下の具体的なケースで見ていきます。

> N = 7, h = (2,9,4,5,1,6,10)

また、頂点iにたどり着くまでのコストを配列 dp に格納していきます。

### 頂点0 へのコスト

始点のためコストはなく、 dp[0] == 0 となります。

### 頂点1 へのコスト

経路は頂点0から意外にないため、 dp[1] == |h0 - h1| == 7 となります。

### 頂点2 へのコスト

頂点2への経路は2通りあり、

|経路|コスト|
|---:|:---|
|頂点1から|&#124;h2 - h1&#124; == 5|
|頂点0から|&#124;h2 - h0&#124; == 2|

## 解答

以上の性質を利用して問題を解きます。

```swift
var dp: [Int] = [0]
func minCost(i: Int, h: [Int], dp: inout [Int]) -> Int {
  // ベースケース
  if i < 1 {
    return dp[0]
  }
  if i == 1 {
    dp.insert(abs(h[0] - h[1]), at: 1)
    return dp[1]
  }
  // i番目に至る経路は i-1 からと i-2 からのケースがある
  let costOfCase1 =  minCost(i: i-1, h: h, dp: &dp) + abs(h[i] - h[i-1])
  let costOfCase2 =  minCost(i: i-2, h: h, dp: &dp) + abs(h[i] - h[i-2])
  dp.insert(min(costOfCase1, costOfCase2), at: i)
  return dp[i]
}

let h = [2,9,4,5,1,6,10]
print("Minimum cost is", minCost(i: h.count-1, h: h, dp: &dp))
```

## ✅用語のチェック

### 部分構造最適性（optimal substructure)

`元の問題の最適性を考える時に、小さな部分問題についても最適性が要求される` という構造をいいます。

このような **部分構造最適性** を利用して各部分問題に対する最適値を順に決定していく手法を **動的計画法** といいます。