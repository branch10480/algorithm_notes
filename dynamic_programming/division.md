# 区間分割最適化

## 区間の表し方

区間は N個の要素のうちの `両端` と `隙間` を合わせた候補 N+1 個分（0, 1, ..., N）から2つ分選ぶ方法に対応します。

区間の左端に対応する番号を `l` 、 右端を `r` としてこの区間を `[l, r)` と表すことにします。

```
要素:  0 1 2 3 4
仕切: 0 1 2 3 4 5
```

この区間 `[l, r)` に含まれる要素は al, al+1, ..., ar-1 の `r-l` 個あります。

注意するべきは `[l, r)` には `ar` が含まれないことです。

## 例題

> N個の要素が1列に並んでいて、これらをいくつかの区間に分割したいものとします。<br>
> 区間 `[l, r)` にはスコア `cl,r` がついているとします。
> 
> K をN以下の正の整数として、 K+1 個整数 t0, t1, ..., tk を `0=t0 < t1 < ,,, < tk = N` を満たすようにとったとき、区間分割 `[t0, t1)` 、 `[t1, t2)` 、 ...、 `[tk-1, tk)` のスコアを
> ```shell
> Ct0,t1 + Ct1,t2 + ... + Ctk-1,tk
> ```
> によって定義します。
> 
> N要素の区間分割の仕方を全て考えた時の考えられるスコアの最小値を求めてください。

例えば

```
N=10
K=4
t=(0,3,7,8,10)
```

の場合のスコアは以下のようになります。

```
C0,3 + C3,7 + C7,8 + C8,10
```

## 解答への足掛かり

まず、dp を定義します。

> dp[i] ... <br>
> 
> 区間 [0, i) について、いくつかの区間に分割する最小コスト

最後に区切る位置が j = (0, 1, ..., i-1) であったとき、区間 [0, i) のコストの和は `区間 [0, j) のコストの和に コスト Cj,i を足したもの` とみなすことができます。

```
要素:  0 1 2 3 4
仕切: 0 1 j 3 i 5
```

## 解答

```swift
// 緩和用のメソッド
func chmin(target: inout Int, new: Int) {
  if new < target {
    target = new
  }
}

let N = 10
let K = 4
var c: [[Int]] = Array(
  repeating: Array(repeating: 0, count: N+1),
  count: N+1
)
// 暫定的にコストを提供する配列を用意する
for i in 0...N {
  for j in 0...N {
    c[i][j] = j
  }
}

// dp の初期化
var dp = Array(repeating: Int.max, count: N+1)

// ここで dp[m] を、区間 [0, m) をいくつかに分割した際のコストの最小和とし、
// これから dp[m] を求めるケースを考える。
// n を 0 < n < m として、 d[m] となる場合の最後に仕切りを入れた箇所を n とみると
// dp[m] とは dp[n] にコスト Cn,m を加えたものとなる。

// dp[0] は区間が存在しないのでコストは 0
dp[0] = 0

for i in 0...N {
  for j in 0..<i {
    chmin(target: &dp[i], new: dp[j] + c[j][i])
  }
}

print("区間 [0, i) をいくつかに分割したコストの最小和は", dp[N])
```



