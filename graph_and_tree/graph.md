# グラフ

## グラフの考え方

**グラフ（graph）** とは対象物の関係性を示します。

> 例）クラスメイトのうち誰と誰が知り合いか

通常、丸と線を用いて表します。

丸を **頂点（vertex）** と呼び、線を **辺（edge）** と呼びます。

## 用語の定義

グラフ G を

- 頂点（vertex）の集合 V = {v1, v2, ..., vN}
- 辺（edge）の集合 E = {e1, e2, ..., eN}

の組として定義し、G=(V, E) と表します。

各辺 e を 2つの頂点 vi, vj の組として定義して e=(vi, vj) とします。

**頂点 vi, vj が辺 e によって結ばれている** 時、vi と vj は互いに **隣接している（adjacent）** と言い、vi, vj を e の **端点（end）** と言います。

また、辺 e は vi, vj に **接続している（incident）** と言います。

各辺 e に実数値または整数値を取る重みが付随したグラフになることもあり、そのグラフを **重み付きグラフ（weighted graph）** と呼びます。

逆に、各辺に重みがついていないグラフを **重みなしグラフ** と呼びます。

複数本の辺が同一頂点を結ぶ時、それらを **多重辺（multiedge）** であると呼び、両端店を同じくする辺 e=(v, v) を **自己ループ（self-loop）** と言います。

多重辺も自己ループも持たないグラフを **単純グラフ（simple graph）** と呼びます。

## 有向グラフと無向グラフ

辺に矢印が付く、向きが存在するグラフを **有向グラフ（directed graph）** 、向きが存在しないグラフを **無向グラフ（undirected graph）** と言います。

### より正確な有向グラフと無向グラフの定義

|種類|定義|
|---:|:---|
|有向グラフ|辺 e=(vi, vj) と e=(vj, vi) を **区別する** グラフのこと|
|無向グラフ|辺 e=(vi, vj) と e=(vj, vi) を **同一視する** グラフのこと|

## ウォーク、サイクル、パス

グラフ G=(V, E) に対して、グラフ G'=(V', E') が **部分グラフ(subgraph)** であるとは、頂点集合 V' が元の頂点集合 V の部分集合であり、辺集合 E' が元の辺集合 E の部分集合であり、任意の辺 e' についてその両端点が V' に含まれることを言います。
つまり、元のグラフの一部であり、それ自身もグラフであるものを部分グラフと言います。

これから見ていく `ウォーク` `サイクル` `パス` はいずれも部分グラフの一種であり、重要です。

### ウォーク

グラフ G 上の2頂点 s, t について、s から t へと隣接する頂点をたどっていくことで到達できるとき、その経路を **s-t ウォーク（walk）** または **s-t 路** と言います。この時、s を **始点** 、t を **終点** と呼びます。

### サイクル

ウォークのうち、始点と終点が等しいものを **サイクル（cycle）** または **閉路** と呼びます。

### パス

さらにウォークのうち、特に同じ頂点を二度以上通らないものを **パス（path）** または **道** と呼びます。

ウォークやサイクルは同じ頂点を二度以上通ってもよいということに注意します。

### 有向グラフにおける、ウォーク、サイクル、パス

有効グラフに対するウォーク、サイクル、パスについては、それらに含まれる各辺の向きが視点から終点への方向に沿っている必要があります。

また、有効グラフに関するウォーク、サイクル、パスを強調したい時は、それぞれ **有向ウォーク** 、 **有向サイクル** 、 **有向パス** と呼びます。

加えて、ウォーク、サイクル、パスの長さ（length）とは、重み付きグラフの場合はそれらに含まれる辺の重みの総和を表し、重みなしグラフの場合はそれらに含まれる辺の本数を表すものとします。

### 【注意】ウォーク、サイクル、パスについての定義はまちまち

この3つの定義は書籍によって、定義がバラバラである点に注意する。

## 連結性

無向グラフGの任意の2頂点 s, t に対して s-t パスが存在する時、Gは **連結(connected)** であると言います。

連結でないグラフとは、どれかの頂点がどこの頂点とも繋がっていないグラフです。

連結とは限らないグラフに関する問題を解くときに、まず連結グラフに対する結果を求めてからそれを各連結成分に対して適用するとうまくいくことがあります。

e.g.) **二部グラフ判定**

### 有向グラフにおける連結強弱

**強連結** ... 有効グラフに置いて任意の頂点 s, t について、s-t, t-s の2つともパスが存在すること。
**弱連結** ... 有効グラフの辺の向きを無視して無向グラフとしたときに連結グラフであるときの呼び方（s-t, t-s のいずれかは存在するとき）

## グラフを用いる定式化の例

グラフは非常に強力な数理科学的ツールで、世の中の多くの問題はグラフを用いてモデル化することでグラフに関する問題とすることができます。

### 1. ソーシャルネットワーク
e.g.) クラスにおける知り合いの関係、Facebook/Twitterの友達・フォロワーの関係など）

**中心部が密に繋がって先端の方へと広がっていくような形状** となる傾向があります。

### 2. 交通ネットワーク

e.g.) 道路ネットワーク、鉄道路線図

特徴は **平面的である** ということ。

### 3. ゲームの局面遷移
e.g.) 将棋、オセロ

### 4. タスクの依存関係
「このタスクを終了しなければ、このタスクを開始することができない」というタスクの依存関係も有向グラフとして表せます。

全タスクを終了させる上でボトルネックになるクリティカルパスを求めることができるようになります。

**クリティカルパス** ... その経路上の作業が遅れると全体に遅延を生じさせるようなパス

## グラフの実装

グラフを表すデータ構造として代表的なものには2つあります。

- **隣接リスト表現** (adjacency-list representation)
- **隣接行列表現** (adjacency-matrix representation)

グラフに関する問題を考える時、隣接リスト表現の方が効率良いアルゴリズムを設計できることが多々あります。

### 例

グラフの頂点集合を V={0,1,...,N-1} とします。（V ... Vertex: 頂点)

そして辺集合を E={v0, v1, ..., vN-1} とします (E ... Edge: 辺)

隣接リスト表現では拡張点 v に対して (v, v') が E に含まれる v' を列挙します。

この作業は 有向グラフ、無向グラフの両方で可能です。

### 実装方針

隣接リスト表現は本来各頂点 v に対する隣接頂点の全体を連結リストで管理するものですが、 **可変長配列** を用いるだけで十分です。

```swift
typealias Graph = [[Int]]
var g: Graph = []
```

このとき、G[v]がvの隣接頂点の集合を表します。

```swift
g = [
  [5],
  [3, 6],
  [5, 7],
  [0, 7],
  [1, 2, 6],
  [],
  [7],
  [0],
]
```

ここで、グラフを表すデータ入力は次のようになるとします。

> N ... a0, a1, ..., aM-1
> M ... b0, b1, ..., bM-1

i(=0,1,...,M-1)番目の辺が、頂点 ai と bi を結ぶことを表します。

そして有向グラフの場合は ai から bi への辺があることを表し、無向グラフの場合は ai と bi を結ぶ辺があるとします。

上の g の持ち方になる入力は以下の通りです。

> N: 8, 4, 4, 4, 1, 1, 2, 2, 6, 3, 3, 7, 0<br>
> M: 13, 1, 2, 6, 3, 6, 5, 7, 7, 0, 7, 0, 5

以上の入力でグラフのデータ構造を生成する処理は以下になります。

```swift
// 有向グラフか無向グラフか
let isDirective = true
// グラフ型の定義
typealias Graph = [[Int]]
// 頂点数と辺数
let N: Int, M: Int
(N, M) = readLineAndGetTwoInts(
  separatedBy: " ",
  message: "頂点と辺の数を入力してください（' '区切り）"
)

// グラフ
var g: Graph = Array(repeating: [], count: N)
for _ in 0..<M {
  let (a, b) = readLineAndGetTwoInts(
    separatedBy: " ",
    message: "2つの頂点を入力して辺情報を入力します。\n数値を2つ ' ' 区切りで入力してください。"
  )
  g[a].append(b)
  
  // 無向グラフの場合
  if !isDirective {
    g[b].append(a)
  }
}
```

## 重み付きグラフの実装

**重み付きの辺** を表す構造体 `Edge` を用意します。

重み付きグラフでは、 G[v] が v に接続している辺（構造体 `Edge` のインスタンス）の集合を表すようにします。

ちなみにこのデータ構造は、最短経路などで用いることになります。

```swift
struct Edge {
  /// 隣接頂点番号(Vertex Number)
  let vNo: Int
  /// 重み
  let weight: Int
}
// 有向グラフか無向グラフか
let isDirective = true
// 各頂点の隣接リストを辺集合で表す 辺: Edge
typealias Graph = [[Edge]]

// MARK: - Main
func main() {
  // 頂点数と辺数
  let N: Int, M: Int
  (N, M) = readLineAndGetTwoInts(
    separatedBy: " ",
    message: "頂点と辺の数を入力してください（' '区切り）"
  )
  
  // グラフ
  var g = Array(repeating: [], count: N)
  for _ in 0..<M {
    let (a, b) = readLineAndGetTwoInts(
      separatedBy: " ",
      message: "2つの頂点を入力して辺情報を入力します。\n数値を2つ ' ' 区切りで入力してください。"
    )
    let weight = readLineInt(message: "その重みを入力してください")
    g[a].append(Edge(vNo: b, weight: weight))
  }
  
  print(g)
}
```

