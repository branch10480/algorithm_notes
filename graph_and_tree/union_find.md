# Union-Find

**Union-Find** とは、**グループ分けを管理するデータ構造** であり、以下のクエリを高速に処理するものです。

N個の要素 0, 1, ..., N-1 を扱うものとし、初期状態ではこれらがすべて別々のグループに属するものとします。

- **issame(x, y)**: 要素x, yが同じグループに属するかどうかを調べる
- **unite(x, y)**: 要素xを含むグループと、要素yを含むグループとを併合する

# Union-Find の仕組み

Union-Find は1つ1つのグループが根付き木を構成するようにして実現できます。

ヒープや二分探索木とは異なり、二分木である必要はありません。

# Union-Find の root 関数

- **root(x)**: 要素xを含むグループ（根付き木）の根を返す

やっていることは頂点xから辿っていき、根に到達したらそれを返すということです。

root(x) の計算量は `O(h)` です。（hは根付き木の高さ）

この root(x) を用いて、上に上げたクエリを処理できます。

|クエリ|処理|
|---:|:---|
|issame(x, y)|root(x) と root(y) が等しいか調べる|
|unite(x, y)|rx = root(x), ry = root(y) として、頂点rxが頂点ryの子頂点となるようにつなぐ|

いずれも root(x) 関数を用いることから計算量は `O(h)` となります。

# Union-Find の計算量を削減する工夫

- union by size (または union by rank)
- 経路圧縮

## union by size

比較的簡単に実現でき、かつ汎用性が高い方法です。

unite(x, y) の実現では以下の2通りが可能であることに着目します。

rx = root(x), ry = root(y) とします。

1. rx を ry の子頂点とする
2. ry を rx の子頂点とする

union by size では、**頂点数がより小さい方の根付き木の根が、小頂点となるようにつなぐ** ということをします。

こうすることで、計算量を `O(logN)` にすることができるのです。

証明は略。

この Union-Find における **サイズが小さい方のデータ構造を大きい方に併合する** という手法は一般的に使えるテクニックなので心に留めておくこと！

## 経路圧縮

union by size に加え、**経路圧縮** をすることで計算量をさらに `O(a(N))` にまで減らすことができます。

union by size は **unite(x, y)についての工夫** でしたが、経路圧縮は **issame(x, y)** についての工夫です。

経路圧縮なしの root(x) は以下のように実装できます。

> parent: [Int] について、頂点 x の親を parent[x] とします<br>
> また、parent[x] == -1 のときは頂点 x が根で有ることを示します

```swift
func root(x: Int) -> Int {
  if parent[x] == -1 {
    return x                // parent[x] == -1 は頂点のときなので x を返す
  }
  else {
    return root(parent[x])  // 親に対して再帰呼び出し
  }
}
```

TODO: 経路圧縮の場合の処理から！

