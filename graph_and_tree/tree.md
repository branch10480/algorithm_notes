# 木

**木** とはグラフの特殊ケースで、これを学ぶと扱えるデータ構造の幅が広がります。

## 定義

無向グラフ G=(V, E) が **木(tree)** であるとは、以下のことを指します。

> G が連結でかつサイクルを持たない

## 根付き木

木に対し、 **特定の頂点を特別扱い** して `根` と呼ぶことがあります。

そしてその根を持つ木のことを **根付き木(rooted tree)** と呼び、逆に根を持たない木を **根無し木(unrooted tree)** と呼びます。

根付き木を描画するときには **根を一番上に描く** のが通例です。

根付き木において、根を除く頂点のうち、**その頂点に接続している辺が1本しかない** ものを `葉(leaf)` と呼びます。

また、根以外の各頂点 v について、v に隣接している頂点のうち、根側にある頂点 p を v の **親(parent)** といい、 v は p の **子(child)** であるといいます。

同一の親をもつ頂点同士は **兄弟(sibling)** であるといいます。

### 根付き木の特徴

- 根は親を持たない
- 葉は子を持たない
- 根以外の各頂点に対しては親は一つに決まる
- 葉以外の頂点は少なくとも一つ以上の子を持つ

## 部分木と木の高さ

根付き木の各頂点 v について、v から見て子頂点の方向のみに着目すると、これは v を頂点とする **部分期(subtree)** と呼びます。

部分期に含まれる頂点のうち、v 以外のものを v の **子孫(descendant)** といいます。

また、根付き木上の2頂点 u, v を指定したとき、u-v パスは **ただ一つに決まり** ます。(根無し木に対しても当てはまります)

ここで再度、木の定義を確認しておきます。そうするとパスが1つに決まるイメージが付くはずです。

> 連結でサイクルを持たない

## 根付き木の形状を活用したデータ構造

ここから、根付き木の形状を活用したデータ構造について見ていきます。

- ヒープ
- 二分探索木
- Union-Find

### 順序木と二分木

根付き木において各頂点 v の子頂点の順序を考えるとき、特に **順序木(ordered tree)** といいます。

この順序木では兄弟間で「兄」「弟」の区別が付くことになります。

順序木を表現する方法として次のようなものがあります。

#### 順序木を評点する方法1

頂点 v に対して、

- 親頂点へのポインタ
- 各子頂点へのポインタを格納した可変長配列

#### 順序木を評点する方法2

頂点 v に対して、

- 親頂点へのポインタ
- 「第一子」を表す頂点へのポインタ
- 「次の弟」を表す頂点へのポインタ

ここで使う nil は、連結リストにおける番兵と同じような働き方をします。

### k分岐と二分木

順序木のうち、すべての頂点に対して高々 k 個の子頂点しかもたないものを **k分木(k-ary tree)** と呼びます。

k分木において k=1 としたものは **連結リスト** に一致します。

そして、k=2 にしたものを **二分木(binary tree)** と呼びます。

二分木において、左側の子頂点を根とした部分木を **左分木(left subtree)** 、右側を **右分木(right subtree)** と呼びます。

二分木は **計算量解析において好都合な形状をしている** ことからさまざまだデータ構造において二分木の構造が採用されています。

二分木を用いる代表的なデータ構造の例としては以下があります。

- ヒープ
- 二分探索木

### 強平衡二分木

熱木々の構造を持つデータ構造は、多くの場面において各クエリにおいての計算量が `O(h)` となります。(h は木の高さ）

よって、どれだけ木の高さ h を小さくできるかが肝となります。

木の超点数を N とすると、高さは最大で N - 1 (=O(N)) となります。

一般の木二分木では各頂点から左右への辺ののび方はまちまちであり、すぐに葉に到達するものもあれば、葉に到達するまでに時間がかかってしまう伸び方をしているものが出てきます。

これではあまり役に立ちません。

しかし、各頂点について左右への辺ののび方が均等である場合には大変有用なものになります。

二分木の中でも特によい性質を持つのが **強平衡二分木(strongly balanced binary tree)** です。

#### 強平衡二分木の定義

> 二分木であり、すべての葉の深さが高々 1 しか違わないもの

#### 計算量

強平衡二分木では、超点数を N として高さが `O(logN)` となります。

### 完全二分木

強平衡二分木よりさらに特殊な **すべての葉の深さが等しい二分木 - 完全二分木(complete binary tree)** について考えます。

完全二分木の高さを h とすると

```
N = 1 + 2^1 + 2^2 + ... + 2^h = 2^h+1 - 1
```

となり、 `h = O(logN)` となります。

### ヒープ

ヒープとは **頂点 v がキーと呼ばれる値 key[v] を持つ二分木** のことをいいます。

#### ヒープの条件

- 頂点v の親頂点を p としたとき、key[p] >= key[v] が成立する
- 木の高さを h としたとき、木の深さ h-1 以下の部分については完全二分木を形成している
- 木の高さを h としたとき、木の深さ h の部分については、頂点が左詰めされている

よって、 **ヒープは強平衡二分木** になっています。

ゆえに様々なクエリを `O(logN)` の計算量で処理することができます。

**ヒープのクエリ処理**

| クエリ | 計算量 | 備考 |
| :--- | :--- | :--- |
| 値 x を挿入する | O(logN) | 挿入後もヒープの条件を満たすようにします。 |
| 最大値を取得する | O(1) | 根の値を取得すればよいだけです。 |
| 最大値を削除する | O(logN) | ヒープから根を削除した後、ヒープの形状を整えます。 |

ハッシュテーブルや二分探索木とは違い、ヒープは「値x をキーにもつ要素を検索する」というクエリには適していません。

ヒープ中のすべての頂点を探索することで検索クエリに答えることができますが、計算量は `O(N)` になります。

#### ヒープの実現方法

- ヒープの根を配列の0番目に対応させる
- ヒープの深さ1の頂点を配列の 1, 2 番目に対応させる
- ヒープの深さ2の頂点を配列の 3, 4, 5, 6 番目に対応させる
- ヒープの深さ3の頂点を配列の 7, 8, 9, 10, 11, 12, 13, 14 番目に対応させる

まとめると、以下のように処理していきます。

- ヒープの深さ d の各頂点を配列の 2^d - 1, ..., 2^d+1 - 2 番目に対応させる

このとき次のような関係が成立しています。

- 配列中の添え字が k である頂点の左右の子頂点の、配列中の添え字がそれぞれ `2k + 1`、`2k + 2` になる
- 配列中の添え字が k である頂点の親頂点の、配列の添え字が `(k - 1)/2` になる 



